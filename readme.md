# Learning Encryption By Python
- https://amzn.asia/d/6lmkgDx
## create venv
- ターミナルを開く
- `python -m venv venv`
- `touch .gitignore`
- `vim .gitignore`
- i
- `venv/`
- esc
- :wq
- Ctrl + Shift + p
- `select interpreter`
  - venvとつく方のインタープリタを選択
- `Set-ExecutionPolicy -ExecutionPolicy Unrestricted -Scope Process`
  - ポリシーを一時的に変更し，スクリプトの実行を許可
- `. venv/Scripts/activate`
- `deactivate`
  - 仮想環境の非アクティブ化
## unittest
- `python -m unittest discover`
## RSA公開鍵暗号の仕組み
- pとqが素数であり，mが0~pqの間の数であれば，任意の正の整数kについて次の式が成り立つ
  - `1={ m^(k(p-1)(q-1)) }%pq`
- これより，以下も成り立つ
  - `m={ m^(k(p-1)(q-1)+1) }%pq`
- pとqを使えばmからm^(k(p-1)(q-1)+1)への変換，m^(k(p-1)(q-1)+1)からmへの変換が可能になる
- ただし，暗号化にも復号化にもpとqが必要であれば共通鍵暗号と変わらないので，`k(p-1)(q-1)+1=e×d`となるeとdを見つけeのみ公開する
- これによって，`c=(m^e)%n`で暗号化し`(c^d)%n`で復号化できるようになる
  - `(c^d)%n={ ((m^e)%n)^d }%n={ m^(e×d) }%n`が成り立つ
    - **剰余を求める際に指数部分は分離できる**
  - `(c^d)%n={ m^(e×d) }%n={ m^(k(p-1)(q-1)+1) }%n={ m×m^(k(p-1)(q-1)) }%n`
  - `1={ m^(k(p-1)(q-1)) }%n`が成り立つので，`(c^d)%n=m%n`
  - `m<n`つまり`m<pq`であれば，`m%n=m`が成り立つ
  - よって，`(c^d)%n=m`(復号化)
- 安全性の担保
  - 暗号鍵から復号鍵が作成できないこと
  - ただ，推測する手順は存在する
    - nを素因数分解してpとqを求める
    - k(p-1)(q-1)%e=0となるkを探し，dを求める
  - しかし，因数分解のステップはpとqを2進数で数百桁となるように設定すると，現在の最良の因数分解アルゴリズムを用いても，pとqを求めるのに数年かかることがわかっている
  - つまり，暗号化されたメッセージはその重要度が失われるほど十分に長く安全が保証される
-  暗号化と復号化の手順
   - 互いに異なる素数pとqを選び，その積をnとする
   - そのうえで，別の正の整数eとdを，ある正の整数kについてe×d=k(p-1)(q-1)となるように選ぶ
   - eとnを公開鍵として配布し，d,p,qを秘密鍵として保持しておく
- 暗号化と復号化の例
  - 公開鍵，秘密鍵の作成
    - p=3, q=7とする
    - n=p×q=21となる
    - k=5とするとk(p-1)(q-1)+1=61となる
    - 60=1×61よりe=4, d=15と定まる
  - メッセージの暗号化
    - メッセージm=101（2進数）=5を暗号化する
    - m^e=5^4=625
    - 625%n=625%21=16=10000(2進数)
  - メッセージの複合化
    - 10000(2進数)=16を復号化する
    - 16^d=16^15=1152921504606846976
    - 1152921504606846976%n=1152921504606846976%21=1
- 追記
  - 量子コンピューターを使用すると素因数分解が劇的に速く溶けるようになる可能性がある